/*
TODO:
 - Fix exploit: player kills over and over
 - Add set amount gathered before rewarded
*/

using System;
using System.Collections.Generic;
using System.Linq;

using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Libraries;

namespace Oxide.Plugins
{
    [Info("Gather Rewards", "CanopySheep", "1.3.2", ResourceId = 770)]
    [Description("Gain money through Economics/Server Rewards for killing and gathering.")]
    class GatherRewards : RustPlugin
    {
        // Do NOT edit this file, instead edit GatherRewards.json in server\<identity>\oxide\config

        #region Configuration Defaults

        PluginConfig DefaultConfig()
        {
            var defaultConfig = new PluginConfig
            {
                Settings = new PluginSettings
                {
                    ShowMessages = true,
					UseEconomics = true,
					UseServerRewards = false,
					PluginPrefix = "<color=cyan>[GatherRewards]</color>",
                    Rewards = new Dictionary<string, float>
                    {
                        { PluginRewards.Player, 0 },
                        { PluginRewards.Ore, 25 },
                        { PluginRewards.Wood, 25 },
						{ PluginRewards.Stone, 25}
                    }
                },
                Messages = new Dictionary<string, string>
                {
                    { PluginMessage.ReceivedForGather, "You have received ${0} for gathering {1}." },
                    { PluginMessage.ReceivedForKill, "You have received ${0} for killing a {1}." },
                }
            };
            foreach (GameManifest.PooledString str in GameManifest.Get().pooledStrings)
            {
                if (str.str.StartsWith("assets/bundled/prefabs/autospawn/animals/"))
                {
                    var animal = str.str.Substring(str.str.LastIndexOf("/") + 1).Replace(".prefab", "");
                    defaultConfig.Settings.Rewards[UppercaseFirst(animal)] = 25;
                }
            }
            return defaultConfig;
        }

        #endregion
		
        #region Configuration Setup

        private bool configChanged;
        private PluginConfig config;

        static class PluginRewards
        {
            public const string Player = "Player";
            public const string Ore = "Ore";
            public const string Wood = "Wood";
			public const string Stone = "Stone";
        }

        static class PluginMessage
        {
            public const string ReceivedForGather = "ReceivedForGather";
            public const string ReceivedForKill = "ReceivedForKill";
        }

        class PluginSettings
        {
            public bool ShowMessages { get; set; }
			public bool UseEconomics { get; set; }
			public bool UseServerRewards { get; set; }
			public string PluginPrefix { get; set; }
            public Dictionary<string, float> Rewards { get; set; }
        }

        class PluginConfig
        {
            public PluginSettings Settings { get; set; }
            public Dictionary<string, string> Messages { get; set; }
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(DefaultConfig(), true);
            PrintWarning("New configuration file created.");
        }

        void LoadConfigValues()
        {
            config = Config.ReadObject<PluginConfig>();
            var defaultConfig = DefaultConfig();
            Merge(config.Messages, defaultConfig.Messages);
            Merge(config.Settings.Rewards, defaultConfig.Settings.Rewards);

            if (!configChanged) return;
            PrintWarning("Configuration file updated.");
            Config.WriteObject(config);
        }

        void Merge<T1, T2>(IDictionary<T1, T2> current, IDictionary<T1, T2> defaultDict)
        {
            foreach (var pair in defaultDict)
            {
                if (current.ContainsKey(pair.Key)) continue;
                current[pair.Key] = pair.Value;
                configChanged = true;
            }
            var oldPairs = current.Keys.Except(defaultDict.Keys).ToList();
            foreach (var oldPair in oldPairs)
            {
                current.Remove(oldPair);
                configChanged = true;
            }
        }

        #endregion

        void Loaded() => LoadConfigValues(); 
		
        void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            if (!Economy && !ServerRewards) return;
            var player = entity.ToPlayer();
            //Puts(player.ToString());

            if (player)
            {
                var shortName = item.info.shortname;
                string resource = null;
                float amount = 0;

                if (shortName.Contains(".ore"))
                {
                    amount = config.Settings.Rewards[PluginRewards.Ore];
                    resource = "ore";
                }
				
				if (shortName.Contains("stones"))
				{
					amount = config.Settings.Rewards[PluginRewards.Stone];
					resource = "stone";
				}

                if (dispenser.GetComponentInParent<TreeEntity>() && shortName.Contains("wood"))
                {
                    amount = config.Settings.Rewards[PluginRewards.Wood];
                    resource = "wood";
                }

                if (resource != null && amount > 0)
                {
                    if (config.Settings.UseEconomics) { Economy.CallHook("Deposit", player.userID, amount); }
					if (config.Settings.UseServerRewards) { ServerRewards?.Call("AddPoints", new object[] { player.userID, amount }); }

                    if (config.Settings.ShowMessages)
                    {
                        PrintToChat(player, config.Settings.PluginPrefix + " " + string.Format(config.Messages[PluginMessage.ReceivedForGather], amount, resource));
                    }
                }
            }
        }

        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
			if (entity == null) return;
            if (!Economy && !ServerRewards) return;
            if (!info?.Initiator?.ToPlayer()) return;
			
			float amount = 0;
			var player = info.Initiator.ToPlayer();
			var animal = UppercaseFirst(entity.LookupPrefab().ToString().Replace("[0]", ""));
			bool isAnimal = false;
			
			if (entity.ToPlayer() != null)
			{ 
				var attacker = info.Initiator as BaseCombatEntity;
				amount = config.Settings.Rewards[PluginRewards.Player]; 
				if (player == attacker); { return; }
				animal = "player";
			}
			else
			{
				if (!entity.GetComponent("BaseNPC")) { return; }
				animal = UppercaseFirst(entity.LookupPrefab().ToString().Replace("[0]", ""));
				config.Settings.Rewards.TryGetValue(animal, out amount);
				isAnimal = true;
			}
            if (amount > 0)
            {
                if (config.Settings.UseEconomics) { Economy.CallHook("Deposit", player.userID, amount); }
				if (config.Settings.UseServerRewards) { ServerRewards?.Call("AddPoints", new object[] { player.userID, amount }); }

                if (config.Settings.ShowMessages && isAnimal)
                {
                    PrintToChat(player, config.Settings.PluginPrefix + " " + string.Format(config.Messages[PluginMessage.ReceivedForKill], amount, animal.ToLower()));
                }
                if (config.Settings.ShowMessages && !isAnimal)
                {
                    PrintToChat(player, config.Settings.PluginPrefix + " " + string.Format(config.Messages[PluginMessage.ReceivedForKill], amount, animal));
                }
            }
        }

        #region Plugin Support

        [PluginReference("Economics")]
        Plugin Economy;
		
		[PluginReference("ServerRewards")]
		Plugin ServerRewards;

        #endregion

        #region Helper Methods
		
        static string UppercaseFirst(string s)
        {
            if (string.IsNullOrEmpty(s))
                return string.Empty;
            var a = s.ToCharArray();
            a[0] = char.ToUpper(a[0]);
            return new string(a);
        }

        #endregion
    }
}
